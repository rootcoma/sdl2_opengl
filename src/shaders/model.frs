#version 130
// https://learnopengl.com All lighting
// is from these tutorials.

struct Material {
    sampler2D diffuseSampler;
    sampler2D specularSampler;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
    int type; // 0 = ambient, float diffuse
              // 1 = Sampler Texture0(diffuse) Texture1(specular)
};

struct Light {
    vec3 position;
    vec3 direction;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    // https://learnopengl.com/Lighting/Light-casters
    float innerCutOff;
    float outerCutOff; // Angle
    // http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation
    float constant;
    float linear;
    float quadratic;
    int type; // 0 Directional (sun)
                       // 1 Point (360 lamp)
                       // 2 Spotlight
};

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 cameraPosition;
uniform int numLights;
#define MAX_LIGHTS 16
uniform Light lights[MAX_LIGHTS];
uniform Material material;

in vec3 inVertex;
in vec3 inFragPos;
in vec3 inNormal;
in vec2 inUV;

out vec4 fragColor;

vec3 CalcDirLightFloat(Light light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // combine results
    vec3 ambient  = light.ambient  * material.diffuse;
    vec3 diffuse  = light.diffuse  * diff * material.diffuse;
    vec3 specular = light.specular * spec * material.specular;
    return ambient + diffuse + specular;
}

vec3 CalcDirLight(Light light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // combine results
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuseSampler, inUV));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuseSampler, inUV));
    vec3 specular = light.specular * spec * vec3(texture(material.specularSampler, inUV));
    return ambient + diffuse + specular;
}

vec3 CalcPointLightFloat(Light light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + 
                 light.quadratic * (distance * distance));    
    // combine results
    vec3 ambient  = light.ambient  * material.diffuse;
    vec3 diffuse  = light.diffuse  * diff * material.diffuse;
    vec3 specular = light.specular * spec * material.specular;
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return ambient + diffuse + specular;
}

vec3 CalcPointLight(Light light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + 
                 light.quadratic * (distance * distance));    
    // combine results
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuseSampler, inUV));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuseSampler, inUV));
    vec3 specular = light.specular * spec * vec3(texture(material.specularSampler, inUV));
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return ambient + diffuse + specular;
}

vec3 CalcSpotLightFloat(Light light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction)); 
    float epsilon = light.innerCutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results
    vec3 ambient = light.ambient * material.ambient;
    vec3 diffuse = light.diffuse * diff * material.diffuse;
    vec3 specular = light.specular * spec * material.specular;
    ambient  *= attenuation * intensity;
    diffuse  *= attenuation * intensity;
    specular *= attenuation * intensity;

    return ambient + diffuse + specular;
}

vec3 CalcSpotLight(Light light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    // diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // attenuation
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction)); 
    float epsilon = light.innerCutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
    // combine results
    vec3 ambient = light.ambient * vec3(texture(material.diffuseSampler, inUV));
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuseSampler, inUV));
    vec3 specular = light.specular * spec * vec3(texture(material.specularSampler, inUV));
    ambient  *= attenuation * intensity;
    diffuse  *= attenuation * intensity;
    specular *= attenuation * intensity;

    return ambient + diffuse + specular;
}

void main()
{
    //vec3 Norm = normalize(mat3(transpose(inverse(model))) * inNormal);
    //vec3 FragPos = vec3(model * vec4(inVertex, 1.0));
    vec3 ViewDir = normalize(cameraPosition - inFragPos);

    vec3 outcolor = vec3(0.0f);
    for (int i=0; i<numLights; i++) {
        if (material.type == 0) {
            switch (lights[i].type) {
                case 0:
                    outcolor += CalcDirLightFloat(lights[i], inNormal, ViewDir);
                    break;
                case 1:
                    outcolor += CalcPointLightFloat(lights[i], inNormal, inFragPos, ViewDir);
                    break;
                case 2:
                    outcolor += CalcSpotLightFloat(lights[i], inNormal, inFragPos, ViewDir);
                    break;
            }
        } else if (material.type == 1) {
            switch (lights[i].type) {
                case 0:
                    outcolor += CalcDirLight(lights[i], inNormal, ViewDir);
                    break;
                case 1:
                    outcolor += CalcPointLight(lights[i], inNormal, inFragPos, ViewDir);
                    break;
                case 2:
                    outcolor += CalcSpotLight(lights[i], inNormal, inFragPos, ViewDir);
                    break;
            }
        }
    }

    fragColor = vec4(outcolor, 1.0f);
}
